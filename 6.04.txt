[Функциональные возможности вредоносного ПО]

[Загрузчик]

Загрузчик – это программа, которая загружает другой вредоносный компонент из  интернета и  запускает его в  системе. Это делается путем вызова API UrlDownloadToFile(), который загружает файл на диск. После загрузки он использует API-вызовы ShellExecute(), WinExec() или CreateProcess() для выполнения загруженного компонента. Обычно вы обнаружите, что загрузчики используются как часть шелл-кода эксплойта.
На скриншоте ниже показан 32-разрядный загрузчик вредоносных программ, использующий UrlDownloadToFileA() и ShellExecuteA() для загрузки и запуска двоичного файла вредоносного ПО. Чтобы определить URL, с которого загружается двоичный файл вредоносного ПО, была установлена точка останова при вызове UrlDownloadToFileA(). После запуска кода точка останова сработала, как показано на скриншоте ниже. Второй аргумент UrlDownloadToFileA() показывает URL-адрес, откуда будет загружен исполняемый файл вредоносного ПО (wowreg32.exe), а  третий аргумент указывает местоположение на диске, где будет сохранен загруженный исполняемый файл. В этом случае загрузчик сохраняет загруженный исполняемый файл в каталоге %TEMP% как temp.exe

API:
UrlDownloadToFile()	# загрузка файлов из сети
ShellExecute()		# выполнение программ
WinExec()		# выполнение программ
CreateProcess()		# выполнение программ

[Дроппер]

Дроппер – программа, которая встраивает в себя дополнительный вредоносный компонент. После выполнения дроппер извлекает вредоносный компонент и  помещает его на  диск. Дроппер обычно  встраивает дополнительный двоичный файл в  секцию ресурсов. Для извлечения встроенного исполняемого файла дроппер использует API-вызовы FindResource(), LoadResource(), LockResource() и SizeOfResource(). Ниже инструмент Resource Hacker показывает наличие PE-файла в секции ресурсов образца вредоносного ПО. В этом случае тип ресурса – это DLL.

После выполнения FindResourceA() его возвращаемое значение (хранящееся в  EAX), которое является дескриптором информационного блока указанного ресурса, передается как второй аргумент API LoadResource(). LoadResource() извлекает дескриптор данных, связанный с  ресурсом. Возвращаемое значение LoadResource(), которое содержит извлеченный дескриптор, затем передается в качестве аргумента в API LockResource(), который получает указатель на фактический ресурс. На скриншоте ниже выполнение приостанавливается сразу после вызова LockResource(). Изучение возвращаемого значения (хранящегося в EAX) в окне дампа показывает исполняемое содержимое PE, которое было получено из секции ресурсов.  После извлечения ресурса вредоносная программа определяет размер ресурса (PE-файл) с помощью API SizofResource(). Затем вредоносная программа перемещает DLL на диск с помощью CreateFileA. Извлеченное содержимое PE затем записывается в  DLL с  помощью API WriteFile(). 

API:
FindResource()		#       
LoadResource()		#
LockResource()		#
SizeOfResource()	#
CreateFileA		#
WriteFile()		#

[Кейлоггер]

Кейлоггер – программа, предназначенная для перехвата и  регистрации нажатий клавиш. Злоумышленники используют функциональные возможности кейлоггинга в своих вредоносных программах для кражи конфиденциальной информации (такой как имена пользователей, пароли, данные кредитных карт и т. д.), вводимой через клавиатуру. В этом разделе мы сосредоточимся в основном на  кейлоггерах пользовательского режима. Злоумышленник может регистрировать нажатия клавиш, используя различные методы. Наиболее распространенными методами регистрации нажатий клавиш являются документированные функции API Windows: (a) проверка состояния ключа (с помощью API GetAsyncKeyState()) и (b) установка ловушек (с помощью API SetWindowHookEX()).

[Кейлоггер, использующий GetAsyncKeyState()]

Этот метод включает в себя запрос состояния каждой клавиши на клавиатуре. Для этого кейлоггеры используют API-функцию GetAsyncKeyState(), чтобы определить, нажата клавиша или нет. Из возвращаемого значения GetAsyncKeyState() можно определить, была ли клавиша нажата или отпущена во время вызова функции и была ли клавиша нажата после предыдущего вызова GetAsyncKeyState(). Ниже приведен прототип API-функции GetAsyncKeyState(): SHORT GetAsyncKeyState (int vKey);
GetAsynKeyState() принимает один целочисленный аргумент vKey, который указывает один из 256 возможных кодов виртуальных клавиш. Чтобы определить 
состояние одной клавиши на  клавиатуре, можно вызвать API-интерфейс GetAsyncKeyState(), передав в  качестве аргумента код виртуальной клавиши, связанный с требуемой клавишей. Чтобы определить состояние всех клавиш на клавиатуре, кейлоггер постоянно опрашивает API GetAsyncKeyState() (передавая код каждой виртуальной клавиши в качестве аргумента) в цикле, чтобы
определить, какая клавиша нажата.

API:
GetAsyncKeyState()
GetKeyState()

[Кейлоггер, использующий SetWindowsHookEx()]

Другой распространенный метод кейлоггинга – установка функции (называемой процедурой перехвата) для мониторинга событий клавиатуры (например, нажатия клавиши). В этом методе вредоносная программа регистрирует функцию (процедуру перехвата), которая будет уведомлена, когда происходит событие клавиатуры, и эта функция может записывать нажатия клавиш в файл или отправлять их по сети. Вредоносная программа использует API-интерфейс SetWindowsHookEx(), чтобы указать, какой тип события следует отслеживать (например, клавиатура, мышь и т. д.), и процедуру перехвата, которая должна быть уведомлена, когда происходит событие определенного типа. Процедура перехвата может содержаться в DLL или текущем модуле.

API:
SetWindowsHookEx()	#

[Осуществление контроля вредоноса с помощью HTTP]

Управление и  контроль, осуществляемые вредоносными программами (также называемые C&C или C2), – это то, как злоумышленники взаимодействуют с  зараженной системой и  осуществляют контроль над ней. При заражении системы большинство вредоносных программ связывается с  сервером, контролируемым злоумышленником (сервер C2), чтобы принимать команды, загружать дополнительные компоненты или извлекать информацию. Злоумышленники используют различные методы и протоколы для контроля и управления.(HTTP)

API:
InternetOpen()
InternetConnect()
HttpOpenRequest()
HttpSendRequest()
InternetReadFile()

[Осуществление команды и контроля в пользовательском режиме]

API:
WSAStartup()		# инициализация системы сокетов Windows
Socket()		# создание сокета
GetHostByName()
Connect()
CreateThread()
Send()
Recv()

[Методы персистентности вредоносных программ]

Часто злоумышленники хотят, чтобы их вредоносная программа оставалась на  взломанных компьютерах даже после перезагрузки Windows. Это достигается с помощью различных методов персистентности; они позволяют злоумышленнику оставаться во взломанной системе без повторного заражения. Существует много способов запуска вредоносного кода при каждом запуске
Windows. В  этом разделе вы узнаете о  некоторых методах персистентности, используемых злоумышленниками. Некоторые из  этих методов, описанные в этом разделе, позволяют им выполнять вредоносный код с повышенными привилегиями.

[Запуск ключа реестра]

HKCU\Software\Microsoft\Windows\CurrentVersion\Run
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run
HKCU\Software\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run

[Запланированные задачи]

schtasks
at

[Папка запуска]

Злоумышленники могут добиться персистентности, добавив свой вредоносный двоичный файл в  папки запуска. Когда операционная система запускается, ищется папка запуска и выполняются файлы, находящиеся в этой папке.
Операционная система Windows поддерживает два типа папок автозагрузки: 
(а) общедоступные и (б) общесистемные

Общесистемные папки:
C:\%AppData%\Microsoft\Windows\Start Menu\Programs\Startup
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup

[Записи реестра Winlogon]

Злоумышленник может добиться персистентности, изменив записи реестра,используемые процессом Winlogon. Процесс Winlogon отвечает за обработку интерактивных пользовательских входов и выходов из системы. После аутентификации пользователя процесс winlogon.exe запускает userinit.exe, который запускает сценарии входа и  восстанавливает сетевые подключения. Затем userinit.exe запускает explorer.exe, являющийся оболочкой пользователя по умолчанию. Процесс winlogon.exe запускает userinit.exe из-за указанного ниже значения реестра. Эта запись указывает, какие программы должны выполняться Winlogon при входе пользователя в систему. По умолчанию в качестве этого значения указывается путь к userinit.exe (C:\Windows\system32\userinit.exe). Злоумышленник может изменить или добавить другое значение, содержащее путь к вредоносному исполняемому файлу, который затем будет запущен процессом winlogon.
exe (когда пользователь входит в систему): 
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Userinit

Таким же образом userinit.exe обращается к следующему значению реестра, чтобы запустить оболочку пользователя по умолчанию. По умолчанию это значение установлено в explorer.exe. Злоумышленник может изменить или добавить еще одну запись, содержащую имя вредоносного исполняемого файла, который затем будет запущен userinit.exe:
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\Shell

[Параметры выполнения файла изображения]

Параметры выполнения файла изображения (Image File Execution Options – IFEO) позволяют запускать исполняемый файл прямо под отладчиком. Это дает разработчику возможность отладки своего программного обеспечения для исследования проблем в коде запуска исполняемого файла. Разработчик может создать подраздел с именем своего исполняемого файла в следующем разделе реестра и задать в качестве значения отладчика путь к отладчику:
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\<executable name>

(Можно изменить путь к запускаемому приложению, например когда пользователь запускает калькулятор у него будет запускаться paint)


REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /t REG_SZ /v Debugger /d "C:\windows\system32\cmd.exe" /f

Позволяет изменить "залипание клавиш" на cmd.exe



